package mit.cadlab.dome3.plugin.catalog.core;

import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

/**
 * User: Sangmok Han
 * Date: 2005. 11. 10.
 */
public class CMapping {

    private Set inputNodes;
    private CMappingNode outputNode;
    private String mappingScript;
    private CNamingService namingService;

    /* only invoked by the contructor of CInterfaceOutputParameter and CRelationInputParameter */
    protected CMapping(String outputParamName, CNamingService namingService) {
        this.outputNode = new CMappingNode(outputParamName, this);
        this.inputNodes = new HashSet();
        this.namingService = namingService;
        this.mappingScript = "";
    }

    public String getMappingScript() {
        return (mappingScript == null) ? "" : mappingScript;
    }

    /**
     * use this method to add input nodes and set mapping script
     * this class doesn't have addInputParameterName()
     * because any inputParam cannot make it into the inputParamNames list
     * without showing up in the mapping script.
     * current usages will be:
     *
     * (ex) setMappingScript("=itf.X + itf.Y", Arrays.asList(new String[] { "itf.X", "itf.Y" }) );
     *
     * once parser for mappingScript is developed, we no more need to pass inputParamNames to this method
     * inputParamNames will be automatically generated by parsing a given mappingScript
     *
     * future usages will be:
     * (ex) setMappingScript("=itf.X + itf.Y"); // { "itf.X", "itf.Y" } is automatically set
     *
     * @param mappingScript
     * @param inputParamNames
     */
    public void setMappingScript(String mappingScript, Collection inputParamNames) {
        this.mappingScript = mappingScript;
        inputNodes.clear();
        for (Iterator i = inputParamNames.iterator(); i.hasNext(); ) {
            CMappingNode inputNode = new CMappingNode((String) i.next(), this);
            inputNodes.add(inputNode);
        }
    }

    /** this method automatically extracts inputParamNames from the given mappingScript */
    public void setMappingScript(String mappingScript) {
        this.setMappingScript(mappingScript, CoreUtil.getParamNames(mappingScript, namingService));
        //speedup Clog.debug("inputNodes " + inputNodes + " are parsed from " + mappingScript);
    }

    public void refreshMappingScript() {
        this.setMappingScript(mappingScript, CoreUtil.getParamNames(mappingScript, namingService));
        //speedup Clog.debug("inputNodes " + inputNodes + " are parsed from " + mappingScript);
    }

    /** setMappingScript(String mappingScript) extracts inputParamNames based on namingService at the point of invocation.
     * if the method is called when a CModel is adding its parameters, some parameters that are not added yet could be regarded as a non-existing one and thus not included in inputParamNames.
     * to make sure that all input param names are extracted from the mapping script, use this method. this method will re-extract input param names */
    protected void updateInputParamNamesOfMappingScript() {
        this.setMappingScript(mappingScript);
    }

    public boolean isExecutable() {
        /* executable if  mapped parameters of all input nodes have GREEN_STATUS */
        for (Iterator i = inputNodes.iterator(); i.hasNext(); ) {
            CMappingNode inputNode = (CMappingNode) i.next();

//            CParameter mappedParam = namingService.getParameter(inputNode.getMappedParameterName());
//
//            /* check if the mapping relation is ready to execute (=all inputs are green or white) */
//            if (mappedParam.getStatus() == CConstant.RED_STATUS) {
//                return false;
//            }

            /* check if the mapping relation is ready to execute (=all inputs are green or white) */
            if (inputNode.getStatus() != CConstant.GREEN_STATUS && inputNode.getStatus() != CConstant.WHITE_STATUS) {
                return false;
            }
        }
        return true;
    }

    public Set getInputNodes() {
        return inputNodes;
    }

    public void setInputNodes(Set inputNodes) {
        this.inputNodes = inputNodes;
    }

    public CMappingNode getOutputNode() {
        return outputNode;
    }

    public void setOutputNode(CMappingNode outputNode) {
        this.outputNode = outputNode;
    }

    public String toString() {
        return "[mapping:input=" + inputNodes + ", output=" + outputNode + ", script=" + mappingScript + "]";
    }

    public void changeNamingService(CNamingService namingService) {
        this.namingService = namingService;
    }

    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof CMapping)) return false;

        final CMapping cMapping = (CMapping) o;

        if (inputNodes != null ? !inputNodes.equals(cMapping.inputNodes) : cMapping.inputNodes != null) return false;
        if (mappingScript != null ? !mappingScript.equals(cMapping.mappingScript) : cMapping.mappingScript != null) return false;
        if (namingService != null ? !namingService.equals(cMapping.namingService) : cMapping.namingService != null) return false;
        if (outputNode != null ? !outputNode.equals(cMapping.outputNode) : cMapping.outputNode != null) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = (inputNodes != null ? inputNodes.hashCode() : 0);
        result = 29 * result + (outputNode != null ? outputNode.hashCode() : 0);
        result = 29 * result + (mappingScript != null ? mappingScript.hashCode() : 0);
        result = 29 * result + (namingService != null ? namingService.hashCode() : 0);
        return result;
    }
}
