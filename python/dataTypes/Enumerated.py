# Enumerated.py
# This class implements Enumerated data type
# It's a list, there is a selected item in the list.
# Also stores the name of the list. So its a list of tuples.
# Searching for a name isn't very efficient since this is not a hashtable
# or mapping

# Known bugs: empty enumerated behavior in and/or logically correct...
# doesn't print right -- gives {} the repr of an empty.
# Funny artifact in names..... generated by Java code.... so don't
# use Java getNames() 



from DataType import DataType
from types import IntType, FloatType, StringType
from Real import Real
from Integer import Integer
from Boolean import Boolean
from Vector import Vector
from types import DictType, ListType, TupleType
from mit.cadlab.dome3.objectmodel.dataobject import EnumerationData

class Enumerated(DataType, EnumerationData):
    def __init__(self,tuples=0):
        self.dataType = "Enumerated"
        if isinstance(tuples, EnumerationData):
            EnumerationData.__init__(self, tuples)
        elif isinstance(tuples, Vector):
            EnumerationData.__init__(self, tuples.getData())
            # implemented using builtin python list type
            # We need to do something here!
            # if (type(tupleList)==ListType):
            # we'll just force it to be a list type
        elif tuples==None or tuples==0:
            EnumerationData.__init__(self)
        else:
            EnumerationData.__init__(self)
            #print ' arg: ' + str(valuek)
            tupleList = list(tuples)
            #print 'tupleList =', tupleList
            #print 'range(len(tupleList)) =', range(len(tupleList))
            self.setSize(len(tupleList))
            for i in range(len(tupleList)):
                nextTuple=tupleList[i]
                # Check that it's a tuple
                # otherwise, let it be the value, and we make our own name
                tname = 'item' + str(i)
                tval = None
                # defaults are above
                # attemp to interpret the passed in value.
                if type(nextTuple)==TupleType:
                    if len(nextTuple) >=2:
                        # if there are two or more items, the first is the name
                        # the rest is the value.
                        tname = nextTuple[0]
                        if type(tname) == IntType:
                            # don't want any confusion with index.
                            tname = str(tname)
                    if len(nextTuple)>2:
                        # make a tuple value if there are more than two values.
                        tlist = []
                        for j in range(1,len(nextTuple)):
                            tlist.append(nextTuple(j))
                            tval = tuple(tlist)
                    elif len(nextTuple)==2:
                        # one value
                        tval = nextTuple[1]
                    else:
                        tval = nextTuple
                elif type(nextTuple)==ListType:
                    if len(nextTuple) >= 2:
                        # list has two or more elements, first will be name
                        tname = nextTuple.pop(0)
                        if type(tname) == IntType:
                            tname = str(tname)
                        if len(nextTuple) == 1:
                            # one value
                            tval = nextTuple[0]
                        else:
                            # more than one value
                            tval = tuple(nextTuple)
                    else:
                        tval = nextTuple
                else:
                    tval = nextTuple
                self.setElementName(i,tname)
                self.setElementValue(i,tval)
                # !!!!! Need to add some checks that it's a list
                # of tuples
        self.selected = 0
        
    def __repr__(self):
        #print 'repr'
        return str(self)
    
    def __str__(self):
        #print '__str__'
        if self.getSize() == 0:
            return '{}'
        rS = '{'
        for i in range(self.getSize()):
            rS = rS + str(self.getElementName(i)) + ':' + str(self.getElementValue(i))
            if i == self.getSize()-1:
                rS = rS + '}'
            else:
                rS = rS + ', '
        return rS
    
    # leave to default
    #def __cmp__(self, other):

    ### Might want to do some fixing in terms of behavior with an or
    ### operators when self is zero.... returns enumF and 0 = {}.
    ### Probably should return 0.

    def __nonzero__(self):
        if (self.getSize()== 0):
            #print '__nonzero__ is 0'
            return 0
        else:
            return 1
        
    def __len__(self):
        return self.getSize()
    
    #comparison operations
    def __eq__(self,other):
        if isinstance(other, Enumerated):
            for i in range(self.getSize()):
                if (self.getElementName(i)!=other.getElementName(i)) or (self.getElementValue(i)!=other.getElementValue(i)):
                    return Boolean(0)
            return Boolean(1)
        else:
            raise TypeError, other
            
    def __ne__(self,other):
        if isinstance(other, Enumerated):
            if self.__eq__(other):
                return Boolean(0)
            else:
                return Boolean(1)
        else:
            raise TypeError, other

            
    # implement class methods
    def hasName(self, other):
        namelist = self._getNames()
        # print 'namelist:' + str(namelist)
        if namelist.count(other) > 0:
            return Boolean(1)
        else:
            return Boolean(0)

    def hasNameCI(self, other):
        namelist = self._getNamesLower()
        if namelist.count(other.lower()) > 0:
            return Boolean(1)
        else:
            return Boolean(0)
        
    def _getNames(self):
        namelist = []
        for i in range(self.getSize()):
                namelist.append(self.getElementName(i))
        return namelist

    def _getNamesLower(self):
        namelistLC = []
        for i in range(self.getSize()):
            namelistLC.append(self.getElementName(i).lower())
        return namelistLC

    def _findNameIndex(self, nameS):
        for i in range(self.getSize()):
            if self.getElementName(i)==nameS:
                return i
        return None

    def _getSelectedIndex(self):
            return self.selected

    def _getSelectedName(self):
        return self.getElementName(self.selected)

    def _getSelectedValue(self):
        return self.getElementValue(self.selected)

 ### enumerated functions  
    def set(self, inS):
        if type(inS)==IntType:
            if (inS >= self.getSize()):
                raise ValueError(str(inS) + ' index out of bounds')
            else:
                self.selected = inS
        else:
            indexS = self._findNameIndex(inS)
            if indexS==None:
                raise ValueError('does not contain name: ' + str(inS))
            else:
                self.selected=indexS
            

    def getIndex(self):
        return self._getSelectedIndex()


    def getName(self):
        return self._getSelectedName()

    def getValue(self):
        if not(isinstance(self, Enumerated)):
            raise TypeError, self
        return self._getSelectedValue()


    def size(self):
        return self.getSize()

    def names(self):
        return self._getNames()



